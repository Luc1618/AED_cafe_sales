# -*- coding: utf-8 -*-
"""AED-cafe_sales.ipynb

Automatically generated by Colab.

Original file is located at
    https://colab.research.google.com/drive/1JOjWa5Pqqm7_GHxvUhNqGic6Hv4r_1mv

# Imports e carregamento dos dados
"""

#https://www.kaggle.com/datasets/ahmedmohamed2003/cafe-sales-dirty-data-for-cleaning-training/data
import pandas as pd
import matplotlib.pyplot as plt
import numpy as np
import seaborn as sns
from scipy.stats import chi2_contingency

# Dados fornecidos
itens = ['Coffee', 'Tea', 'Sandwich', 'Salad', 'Cake', 'Cookie', 'Smoothie', 'Juice']
prices = [2, 1.5, 4, 5, 3, 1, 4, 3]

# Carregamento do DataFrame
df = pd.read_csv("dirty_cafe_sales.csv")
df.head()

"""# Informações iniciais sobre o Data Frame

"""

# Informaçõs do Dataframe

## Dimensões do data frame
print(f"Número de linhas e colunas: {df.shape} \n")

## Tipos de dados
print(df.dtypes)

# Verificando os valores assumidos por cada variável
print(f"Item: {df['Item'].unique()} \n")

print(f"Quantity: {df['Quantity'].unique()} \n")

print(f"Price Per Unit: {df['Price Per Unit'].unique()} \n")

print(f"Total Spent: {df['Total Spent'].unique()} \n")

print(f"Payment Method: {df['Payment Method'].unique()} \n")

print(f"Location: {df['Location'].unique()} \n")

# print(f"Transaction Date: {df['Transaction Date'].unique()} \n")

"""# Funções

## Gráficos - frequência e dados ausentes
"""

# Frequência dos dados

def absolut_frequncy(df, columns, colors = []):
  """
  Função para gerar gráficos de frequência absoluta.

  Args:
    df (DataFrame): DataFrame;
    columns (list): Nome das colunas analisadas para obtenção da frequência absoluta;
    colors (list): Lista de cores para os gráficos.
  """

  for i, var in enumerate(columns):

    # Tabela de frequência absoluta
    absfr = df[var].value_counts()

    # Excluindo linhas inúteis
    absfr = absfr.drop(['ERROR', "UNKNOWN"])

    # Configurações do gráfico
    fig, ax = plt.subplots(figsize=(12, 3))
    ax.spines["top"].set_visible(False)
    ax.spines["right"].set_visible(False)
    absfr.plot(kind = 'bar', color = colors[i], zorder = 2)
    plt.xticks(rotation=45)
    plt.title(f"Frequência absoluta da variável '{var}'")
    plt.grid(alpha = 0.4)
    plt.show()
    plt.close()

def data_types_graph(df, columns, search = ["ERROR", "UNKNOWN"]):
  """
  Função que gera um gráfico informando a quantidade relativa de dados válidos
  e inválidos nas colunas parâmetro.

  Args:
  df (DataFrame): Dataframe;
  columns (list): Lista de colunas a serem analisadas pela função;
  search (list): Lista de dados a serem analisados.
  """

  for var in columns:
    # Tabela com os dados inválidos "Error" e "Unknown"
    datatypes = df[var].value_counts().loc[search]

    # Adicionando as quantidades de dados válidos e dados NA
    datatypes.loc[len(datatypes)] = df[var].isna().sum()
    datatypes.loc[len(datatypes)] = df[var].shape[0] - datatypes.sum()

    # Definindo os Index com os nomes dos tipos de dados
    datatypes.index = search + ["Na", "Dados válidos"]

    x = datatypes.index.tolist()
    y = datatypes.values

    # Configurações do Gráfico
    fig, ax = plt.subplots()

    colors = ['#0057b7', '#3d3d3d', '#d3d3d3', '#f4a900']

    ax.pie(y, labels = x, colors=colors,
          wedgeprops={'edgecolor': 'white', 'linewidth': 2}, pctdistance=0.8)

    circle = plt.Circle((0,0), 0.5, color='white')
    ax.add_artist(circle)

    plt.title(f"Tipos de dados da variável '{var}'", fontsize=14, fontweight='bold')
    plt.legend([f"{n}%" for n in (datatypes.values/100).round(2)],
              loc="center left", bbox_to_anchor=(1.2, 0.8))
    plt.show()
    plt.close()

"""## Tratamento de dado"""

def repair_data_item_price(df):
  """
  Função que realiza o reparo dos dados através da relação item-preço_unitário e
  preço_unitário-item.

  Args:
    df (DataFrame): Dataframe.
  """
  # Itens que possuem preços unitários iguais
  itens_reapts = ['Sandwich', 'Cake', 'Smoothie', 'Juice']

  # Reparando os dados via relação item-preço_unitário
  for price, item in zip(prices, itens):

    # Definindo os preços pelos nomes
    df.loc[(df['Item'] == item), 'Price Per Unit'] = price

    # Definindo os nomes pelo preço
    df.loc[(df['Price Per Unit'] == price) & (~df['Item'].isin(itens_reapts)), 'Item'] = item

def repair_data_quantity_price_total(df):
  """
  Função que realiza o reparo dos dados através da relação matemática entre quantidade
  preço unitário e total gasto.

  Args:
    df (DataFrame): Dataframe.
  """

  # Função que busca linhas no data frame, das quais duas das três colunas analisadas
  # possuam dados válidos e a restante, um dado inválido, conforme as ordem dos parâmetros.
  f = lambda x, y, z, colname: df.loc[(df[x].notna()) & (df[y].isna()) & (df[z].notna()), colname]

  # Neste loop, caminhamos por toda combinações da função 'f', preenchendo os dados conforme
  # a relação matemática.
  for x, y, z in zip(
      ['Total Spent', 'Total Spent', 'Price Per Unit'],
      ['Quantity', 'Price Per Unit', 'Total Spent'],
      ['Price Per Unit', 'Quantity', 'Quantity']):

    if y == 'Total Spent':
      df.loc[(df[x].notna()) & (df[y].isna()) & (df[z].notna()), y] = f(x, y, z, x)*f(x, y, z, z)
    elif y == 'Quantity':
      df.loc[(df[x].notna()) & (df[y].isna()) & (df[z].notna()), y] = f(x, y, z, x)/f(x, y, z, z)
    elif y == 'Price Per Unit':
      df.loc[(df[x].notna()) & (df[y].isna()) & (df[z].notna()), y] = f(x, y, z, x)/f(x, y, z, z)

def data_repair(df):
  """
  Função que resolve o problema de dependência ciclíca na imputação dos dados.

  Args:
    df (DataFrame): Dataframe.
  """

  # Função que busca linhas no data frame
  g = lambda x, y, z: df.loc[(df[x].notna()) & (df[y].isna()) & (df[z].notna())]

  # count = 1

  # Aqui, no while, há a verificação das linhas que estão nas condições de serem
  # reparadas pelas funções 'repair_Data_quantity_price_total' e 'repair_data_item_price'.
  # Caso ainda existam, as funções de reparo continuaram rodando.
  while (g('Price Per Unit', 'Quantity', 'Total Spent').shape[0] > 0) or (g('Price Per Unit', 'Total Spent', 'Quantity').shape[0] > 0) or (g('Quantity', 'Price Per Unit', 'Total Spent').shape[0] > 0) or (df[(df['Item'].isna()) & (df['Quantity'].notna()) & (df['Total Spent'].notna())].shape[0] > 0):
    # print(count)
    repair_data_quantity_price_total(df)
    repair_data_item_price(df)
    # count += 1

  return "Dados reparados com sucesso!"

"""# Execução do código

## Estatísticas dos dados faltantes
"""

###### CHAMADA DE FUNÇÃO

# Lista com os nomes de todas as colunas
columns = df.columns.to_list()

# Removendo as colunas que não queremos gráifcos
columns.remove('Transaction ID')
columns.remove('Transaction Date')

data_types_graph(df, columns)

##### CHAMADA DE FUNÇÃO

# Lista com os nomes de todas as colunas
columns = df.columns.to_list()

# Removendo as colunas que não queremos gráifcos
columns.remove('Transaction ID')
columns.remove('Transaction Date')
columns.remove('Quantity')
columns.remove('Price Per Unit')
columns.remove('Total Spent')

cores_cafe = ['#4B382A', '#6F4E37', '#9C6F4A', '#C19A6B', '#D2B48C', '#E3CBA8', '#F3E5D8']

absolut_frequncy(df, columns, cores_cafe)

"""## Tratamento e transformação dos dados"""

# Não há duplicatas
df[df.duplicated()]

# Alteração dos dados de natureza numérica str --> int or float
df['Quantity'] = pd.to_numeric(df['Quantity'], errors='coerce')
df['Price Per Unit'] = pd.to_numeric(df['Price Per Unit'], errors='coerce')
df['Total Spent'] = pd.to_numeric(df['Total Spent'], errors='coerce')
# Mudança do tipo de dado da data da transação
df['Transaction Date'] = pd.to_datetime(df['Transaction Date'], errors='coerce')
print("Dados tranformados.")

data_repair(df)

"""## Estatísticas dos dados faltantes - pós tratamento"""

###### Pós reparo dos dados

# Lista com os nomes de todas as colunas
columns = ['Quantity', 'Price Per Unit', 'Total Spent']

data_types_graph(df, columns, [])
data_types_graph(df, ['Item'])

"""## Análises e estatísticas"""

df.describe()

####### QUANTIDADE DE VENDAS POR MÊS

venda_mes = []
meses = np.arange(1, 13)

# Coletando o valor total de vendas por mês (independe do produto)
for mes in meses:
  venda_mes.append(df.loc[df['Transaction Date'].dt.month == mes, 'Quantity'].sum())

# Configurações do gráfico
fig, ax = plt.subplots(figsize=(10, 3))

ax.spines["top"].set_visible(False)
ax.spines["right"].set_visible(False)
ax.grid(alpha=0.4, linestyle = '--')
ax.plot(
    meses,
    venda_mes,
    zorder = 2,
    marker ='o',
    linestyle = '-',
    color = '#E66A00')
plt.xticks(meses)
plt.xlabel('Month')
plt.ylabel('NUmber of sales')
plt.title('Sales per month')
plt.show()
plt.close()

fig, ax = plt.subplots(figsize=(8, 4))

ax.spines["top"].set_visible(False)
ax.spines["right"].set_visible(False)
ax.grid(alpha=0.4, linestyle = '--')

qtd_per_month = []
for item in itens:
  for mes in meses:
    qtd = df.loc[(df['Item'] == item) & (df['Transaction Date'].dt.month == mes), 'Quantity'].sum()
    qtd_per_month.append(qtd)

  ax.plot(
      meses,
      qtd_per_month,
      marker = 'o',
      zorder = 2,
      linestyle = '-',
      label = item)
  qtd_per_month = []

plt.legend(loc = 'upper right', bbox_to_anchor=(1.22, 0.8))
plt.xlabel('Month')
plt.ylabel('NUmber of sales')
plt.title('Sales per month')
plt.xticks(meses)
plt.show()
plt.close()

df_filter =  df[~df['Item'].isin(['UNKNOWN', 'ERROR'])]
df_filter.boxplot(column = 'Total Spent', by = 'Item', figsize = (12, 3),
  patch_artist=True,
  boxprops=dict(facecolor="#1F77B4", color="#1F77B4"),
  whiskerprops=dict(color="black", linestyle="--"),
  capprops=dict(color="black"),
  medianprops=dict(color="black", linewidth=2))

plt.grid(alpha = 0.4, linestyle='--')
plt.title("Boxplot - Total Spent")
plt.ylabel("Total Spent")
plt.suptitle("")  # Remove o título padrão gerado por pandas
plt.show()
plt.close()

### Gráficos de dispersão

# plt.scatter( df['Total Spent'], df['Quantity'])

matrix_corr = df[['Quantity', 'Total Spent', 'Price Per Unit']].corr()
# Criando um heatmap
plt.figure(figsize=(6,5))
sns.heatmap(matrix_corr, annot=True, cmap='coolwarm', fmt=".2f", linewidths=0.5)
plt.title("Correlação")
plt.show()

df_filter =  df[(~df['Item'].isin(['UNKNOWN', 'ERROR'])) & (~df['Payment Method'].isin(['UNKNOWN', 'ERROR']))]
item_payment = pd.crosstab(df_filter['Item'], df_filter['Payment Method'])

# Realizando o teste qui-quadrado
chi2, p, dof, expected = chi2_contingency(item_payment)

# Exibindo os resultados
print(f"Qui-Quadrado: {chi2:.4f}")
print(f"p-valor: {p:.4f}")
print(f"Graus de liberdade: {dof}")
print("Frequências esperadas:")
print(expected)

df_filter =  df[(~df['Location'].isin(['UNKNOWN', 'ERROR'])) & (~df['Payment Method'].isin(['UNKNOWN', 'ERROR']))]
location_payment = pd.crosstab(df_filter['Location'], df_filter ['Payment Method'])

# Realizando o teste qui-quadrado
chi2, p, dof, expected = chi2_contingency(location_payment)

# Exibindo os resultados
print(f"Qui-Quadrado: {chi2:.4f}")
print(f"p-valor: {p:.4f}")
print(f"Graus de liberdade: {dof}")
print("Frequências esperadas:")
print(expected)

df_filter =  df[(~df['Item'].isin(['UNKNOWN', 'ERROR'])) & (~df['Location'].isin(['UNKNOWN', 'ERROR']))]
item_location = pd.crosstab(df_filter['Item'], df_filter ['Location'])

# Realizando o teste qui-quadrado
chi2, p, dof, expected = chi2_contingency(item_location)

# Exibindo os resultados
print(f"Qui-Quadrado: {chi2:.4f}")
print(f"p-valor: {p:.4f}")
print(f"Graus de liberdade: {dof}")
print("Frequências esperadas:")
print(expected)

"""# O que não fazer"""

# Preencher com isto torna os dados inconcistentes !!!!!!!!!!!
df[df['Quantity'].isna()] = df['Quantity'].median()
df[df['Price Per Unit'].isna()] = df['Price Per Unit'].median()
df[df['Total Spent'].isna()] = df['Total Spent'].median()

len(df[df['Quantity'].isna()])
df[df['Price Per Unit'].isna()]
df[df['Total Spent'].isna()]